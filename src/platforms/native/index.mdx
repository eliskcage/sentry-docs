---
title: Native
---

The Sentry Native SDK is intended for C and C++. However, since it builds as a
dynamic library and exposes C-bindings, it can be used by any language that
supports interoperability with C, such as the Foreign Function Interface (FFI).

Sentry also offers higher-level SDKs for platforms with built-in support for
native crashes:

- [_Android_](/platforms/android/)
- [_Cocoa_](/clients/cocoa/)
- [_Electron_](/platforms/electron/)

In case you would like to use Sentry with a third-party framework directly
without using the Native SDK, see the following resources:

- [_Google Breakpad_](guides/breakpad/)
- [_Google Crashpad_](guides/crashpad/)
- [_Unreal Engine 4_](guides/ue4/)

The Sentry Native SDK has built-in support for both Google Breakpad and Google
Crashpad, see [Integrations](integrations/).

## Install

The Native SDK currently supports **Windows**, **macOS**, **Linux**, and **Android**.

To build the SDK, download the latest release of the SDK from the [Releases
page](https://github.com/getsentry/sentry-native/releases).
The SDK is managed as a [CMake] project, which additionally supports several configuration options, such as the backend to use.

For example, `CMake` can be used like this (on macOS):

```shell
# configure the cmake build into the `build` directory, with crashpad (on macOS)
$ cmake -B build -D SENTRY_BACKEND=crashpad
# build the project
$ cmake --build build --parallel
# install the resulting artifacts into a specific prefix
$ cmake --install build --prefix install
# which will result in the following (on macOS):
$ exa --tree install
install
├── bin
│  └── crashpad_handler
├── include
│  └── sentry.h
└── lib
   ├── libsentry.dylib
   └── libsentry.dylib.dSYM
```

[cmake]: https://cmake.org/cmake/help/latest/

## Configure

After completing the project setup in Sentry, it shows the _Data Source Name_
(DSN). It looks similar to a standard URL, and contains all configuration for
the SDK.

Import and initialize the Sentry SDK early in your application setup:

```c
#include <sentry.h>

int main(void) {
  sentry_options_t *options = sentry_options_new();
  sentry_options_set_dsn(options, "___PUBLIC_DSN___");
  sentry_init(options);

  /* ... */

  // make sure everything flushes
  sentry_shutdown();
}
```

<Alert level="warning" title="Warning"><markdown>

Calling `sentry_shutdown()` before exiting the application is critical. It
ensures that events can be sent to Sentry before execution stops. Otherwise,
event data may be lost.

</markdown></Alert>

Alternatively, the DSN can be passed as `SENTRY_DSN` environment variable during
runtime. This can be especially useful for server applications.

### Verify

Now that SDK setup is complete, verify that all configuration is correct. Start
by capturing a manual event:

```c
sentry_capture_event(sentry_value_new_message_event(
  /*   level */ SENTRY_LEVEL_INFO,
  /*  logger */ "custom",
  /* message */ "It works!"
));
```

Once the event is captured, it will show up on the Sentry dashboard.

## Capturing Events

The Native SDK exposes a _Value API_ to construct values like Exceptions, User
objects, Tags, and even entire Events. There are several ways to create an
event.

### Manual Events

To create and capture a manual event, follow these steps:

1. Create an event value using `sentry_value_new_event`. This internally
   creates an object value and initializes it with common event attributes, like
   a `timestamp` and `event_id`.
2. Add custom attributes to the event, like a `message` or an `exception`.
3. Send the event to Sentry by invoking `sentry_capture_event`.

In a more complex example, it looks like this:

```c
sentry_value_t event = sentry_value_new_event();
sentry_value_set_by_key(event, "message", sentry_value_new_string("Hello!"));

sentry_value_t screen = sentry_value_new_object();
sentry_value_set_by_key(screen, "width", sentry_value_new_int32(1920));
sentry_value_set_by_key(screen, "height", sentry_value_new_int32(1080));

sentry_value_t extra = sentry_value_new_object();
sentry_value_set_by_key(extra, "screen_size", screen);

sentry_value_set_by_key(event, "extra", extra);
sentry_capture_event(event);
```

For the full list of supported values, see [_Event Payloads_](https://develop.sentry.dev/sdk/event-payloads/) and linked
documents.

### Exceptions

To capture an error or exception condition, create events containing an
exception object. It needs to contain at least a value and type:

```c
#include <sentry.h>

sentry_value_t exc = sentry_value_new_object();
sentry_value_set_by_key(exc, "type", sentry_value_new_string("Exception"));
sentry_value_set_by_key(exc, "value", sentry_value_new_string("Error message."));

sentry_value_t event = sentry_value_new_event();
sentry_value_set_by_key(event, "exception", exc);
sentry_capture_event(event);
```

This exception does not contain a stack trace, which must be added separately.

### Message Events

To simplify creating events, there are shorthand functions that construct
prepopulated event objects. The most important one is
`sentry_value_new_message_event`. The `logger` and `message` parameters are each
optional.

```c
sentry_value_t event = sentry_value_new_message_event(
  /*   level */ SENTRY_LEVEL_INFO,
  /*  logger */ "custom",
  /* message */ "It works!"
);
```

### Application Crashes

By default, the Native SDK intercepts crash signals and unhandled exceptions to
send crash reports to Sentry. Depending on the [backend](#integrations), the
crash report can be sent as a conventional event or as a native crash report
file. On Windows, Linux, and macOS, the default backends send binary Minidump
files. Sentry processes them to extract stack traces and exception information
into a readable crash report.

For more information on Minidumps and the limits that apply, see
[What is a Minidump](/platforms/native/minidumps#what-is-a-minidump).

<Alert level="warning" title="Size Limits"><markdown>

The size of Minidumps can vary between a few kilobytes and many megabytes.
Contributing factors are the number of threads, size of stack space, and the
number of heap memory regions referenced from the stack. As Minidumps often
contain large regions of empty memory, the SDK compresses Minidumps before
uploading. Sentry drops requests with a body larger than _20MB_, or if they
contain files larger than _100MB_.

</markdown></Alert>
